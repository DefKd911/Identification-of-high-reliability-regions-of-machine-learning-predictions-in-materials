# -*- coding: utf-8 -*-
"""TCOs.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yO4TfygaoJGpGq8q0P6vnp4ZPuOxDDJ-
"""

import os

import warnings

warnings.filterwarnings('ignore')

# os.chdir('C:\\Users\\HP\\OneDrive\\Desktop\\Identification of high-reliability regions of machine learning predictions in materials\\Datasets')

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

import numpy as np
import math

df_train=pd.read_csv('ci3c01684_si_002.txt')

df_test=pd.read_csv('ci3c01684_si_003.txt')

df=pd.concat([df_train,df_test])

df

print('Total data: ', df.shape)

df.isnull().sum()

df.dtypes

df.describe()

df.duplicated().sum()

sg_counts=df['spacegroup'].value_counts()

Natoms_counts=df['number_of_total_atoms'].value_counts()

plt.figure(figsize=(8,6))
ax = sns.barplot(x=sg_counts.index,y=sg_counts.values,palette='bright')
plt.title('Counts per Space Groups')
plt.xlabel('Space group')
plt.ylabel('Counts')
plt.show()

plt.figure(figsize=(8,6))
ax = sns.barplot(x=Natoms_counts.index.astype('int'),y=Natoms_counts.values,palette='bright')
plt.title('Number of atoms Counts')
plt.xlabel('Number of atoms')
plt.ylabel('Counts')
plt.show()

df['Al_atoms']=df['number_of_total_atoms']*df['percent_atom_al']
df['Ga_atoms']=df['number_of_total_atoms']*df['percent_atom_ga']
df['In_atoms']=df['number_of_total_atoms']*df['percent_atom_in']

df

df['sg']=df['spacegroup'].astype('object')

df=pd.get_dummies(df,dtype=int)

df.drop('id',axis=1,inplace =True)

df

sns.boxplot(data=df,x='number_of_total_atoms',y='Ef',palette='bright')

sns.boxplot(data=df,x='number_of_total_atoms',y='Eg',palette='bright')

sns.boxplot(data=df,x='spacegroup',y='Eg',palette='bright')

sns.boxplot(data=df,x='spacegroup',y='Ef',palette='bright')

fig, ax = plt.subplots(nrows = 2,ncols=1, sharex=True, sharey=True,)
ax[0].scatter(df['percent_atom_al'].values, df['Ef'].values,
              color='red', s=3, label='formation',marker='.')
ax[1].scatter(df['percent_atom_al'].values,df['Eg'].values,
              color='green', s=3, label='bandgap',marker='.')
fig.suptitle('x(Al) vsEf & Eg')
ax[0].legend(loc=0)
ax[0].set_ylabel('Formation energy')
ax[0].set_xlabel('x(Al)')
ax[1].set_ylabel('Band Gap energy')
ax[1].set_xlabel('x(Al)')

plt.show()

fig, ax = plt.subplots(nrows = 2,ncols=1, sharex=True, sharey=True,)
ax[0].scatter(df['percent_atom_ga'].values, df['Ef'].values,
              color='blue', s=3, label='formation',marker='.')
ax[1].scatter(df['percent_atom_ga'].values,df['Eg'].values,
              color='brown', s=3, label='bandgap',marker='.')
fig.suptitle('x(Ga) vsEf & Eg')
ax[0].legend(loc=0)
ax[0].set_ylabel('Formation energy')
ax[0].set_xlabel('x(Ga)')
ax[1].set_ylabel('Band Gap energy')
ax[1].set_xlabel('x(Ga)')

plt.show()

fig, ax = plt.subplots(nrows = 2,ncols=1, sharex=True, sharey=True,)
ax[0].scatter(df['percent_atom_in'].values, df['Ef'].values,
              color='orange', s=3, label='formation',marker='.')
ax[1].scatter(df['percent_atom_in'].values,df['Eg'].values,
              color='green', s=3, label='bandgap',marker='.')
fig.suptitle('x(In) vsEf & Eg')
ax[0].legend(loc=0)
ax[0].set_ylabel('Formation energy')
ax[0].set_xlabel('x(In)')
ax[1].set_ylabel('Band Gap energy')
ax[1].set_xlabel('x(In)')

plt.show()

fig, ax = plt.subplots(nrows = 2,ncols=1, sharex=True, sharey=True,)
ax[0].scatter(df['Al_atoms'].values, df['Ef'].values,
              color='orange', s=3, label='formation',marker='.')
ax[1].scatter(df['Al_atoms'].values,df['Eg'].values,
              color='green', s=3, label='bandgap',marker='.')
fig.suptitle('Al_atoms vsEf & Eg')
ax[0].legend(loc=0)
ax[0].set_ylabel('Formation energy')
ax[0].set_xlabel('Al_atoms')
ax[1].set_ylabel('Band Gap energy')
ax[1].set_xlabel('Al_atoms')

plt.show()

fig, ax = plt.subplots(nrows = 2,ncols=1, sharex=True, sharey=True,)
ax[0].scatter(df['Ga_atoms'].values, df['Ef'].values,
              color='orange', s=3, label='formation',marker='.')
ax[1].scatter(df['Ga_atoms'].values,df['Eg'].values,
              color='green', s=3, label='bandgap',marker='.')
fig.suptitle('Ga_atoms vsEf & Eg')
ax[0].legend(loc=0)
ax[0].set_ylabel('Formation energy')
ax[0].set_xlabel('Ga_atoms')
ax[1].set_ylabel('Band Gap energy')
ax[1].set_xlabel('Ga_atoms')

plt.show()

fig, ax = plt.subplots(nrows = 2,ncols=1, sharex=True, sharey=True,)
ax[0].scatter(df['In_atoms'].values, df['Ef'].values,
              color='orange', s=3, label='formation',marker='.')
ax[1].scatter(df['In_atoms'].values,df['Eg'].values,
              color='green', s=3, label='bandgap',marker='.')
fig.suptitle('In_atoms vsEf & Eg')
ax[0].legend(loc=0)
ax[0].set_ylabel('Formation energy')
ax[0].set_xlabel('In_atoms')
ax[1].set_ylabel('Band Gap energy')
ax[1].set_xlabel('In_atoms')

plt.show()

df.groupby('spacegroup')[['Eg','Ef']].mean().plot(kind='bar')
plt.title('Mean-Space groups')

def one_to_two(x):
    a = x['lattice_vector_1_ang']
    b = x['lattice_vector_2_ang']
    c = x['lattice_angle_gamma_degree']
    return np.sqrt( a**2 + b**2 - 2*a*b*math.cos(math.radians(c)))

df.apply(one_to_two,axis=1)

def one_to_three(x):
    a = x['lattice_vector_1_ang']
    b = x['lattice_vector_3_ang']
    c = x['lattice_angle_beta_degree']
    return np.sqrt( a**2 + b**2 - 2*a*b*math.cos(math.radians(c)))

df.apply(one_to_three,axis=1)

def two_to_three(x):
    a = x['lattice_vector_2_ang']
    b = x['lattice_vector_3_ang']
    c = x['lattice_angle_alpha_degree']
    return np.sqrt(a**2 + b**2 - 2*a*b*math.cos(math.radians(c)))

df.apply(two_to_three,axis=1)

cont=pd.crosstab(df['spacegroup'], df['number_of_total_atoms'])
# contingency table

cont

#Number of atoms = 80 and the counts over spacegroups
cont.plot(kind='bar')
plt.figure()

df.plot(kind="scatter", x="lattice_vector_1_ang", y="lattice_vector_2_ang",figsize=(6,3))

df.plot(kind="scatter", x="lattice_vector_1_ang", y="lattice_vector_3_ang",figsize=(6,3))

df.plot(kind="scatter", x="lattice_vector_2_ang", y="lattice_vector_3_ang",figsize=(6,3))

from mpl_toolkits.mplot3d import Axes3D
fig = plt.figure(figsize=(15,6))
ax = fig.add_subplot(111, projection='3d')
ax.scatter(df['lattice_vector_1_ang'], df['lattice_vector_2_ang'], df['lattice_vector_3_ang'], c=df['number_of_total_atoms'], marker='.')
ax.set_xlabel('lattice_vector_1_ang')
ax.set_ylabel('lattice_vector_2_ang')
ax.set_zlabel('lattice_vector_3_ang')
plt.show()

df

corr_list = ['percent_atom_al','percent_atom_ga','percent_atom_in','Eg','Ef']

corr = df[corr_list].corr()
#Draw the heatmap using seaborn
sns.heatmap(corr, annot=True)

from sklearn.cluster import KMeans
lattice_vectors = np.array(df[['lattice_vector_1_ang','lattice_vector_2_ang','lattice_vector_3_ang']])
kmeans = KMeans(n_clusters=10).fit(lattice_vectors)

df['cluster of lattice']=kmeans.labels_

dummy=pd.get_dummies(df['cluster of lattice'],dtype='int')

dummy.columns = ['clusters_of_lattices_'+ str(r) for r in list(dummy.columns.values)]

df = pd.concat([df,dummy],axis=1)

df.columns

from mpl_toolkits.mplot3d import Axes3D
fig = plt.figure(figsize=(15,6))
ax = fig.add_subplot(111, projection='3d')
ax.scatter(df['lattice_vector_1_ang'], df['lattice_vector_2_ang'], df['lattice_vector_3_ang'], c=df['cluster of lattice'], marker='.',)
ax.set_xlabel('lattice_vector_1_ang')
ax.set_ylabel('lattice_vector_2_ang')
ax.set_zlabel('lattice_vector_3_ang')
plt.title('clustered version of lattices')
plt.show()

df.groupby('cluster of lattice')[['Eg','Ef']].mean().plot(kind='bar')

fig,ax=plt.subplots(nrows=1,ncols=2)
sns.distplot(df['Ef'],bins=100,ax=ax[0])
sns.distplot(df['Eg'],bins=100,ax=ax[1])

df['Lattice_side_1']=df.apply(one_to_two,axis=1)
df['Lattice_side_2']=df.apply(one_to_three,axis=1)
df['Lattice_side_3']=df.apply(two_to_three,axis=1)

def area_calculator(x):
    a = x['Lattice_side_1']
    b = x['Lattice_side_2']
    c = x['Lattice_side_3']
    p = (a+b+c)/2
    return np.sqrt(p*(p-a)*(p-b)*(p-c))

df['area'] = df.apply(area_calculator,axis=1)

df.groupby('number_of_total_atoms')[['Ef','Eg']].mean().plot(kind='bar',figsize=(10,5),legend='reverse')

dummy_2= pd.get_dummies(df['number_of_total_atoms'],dtype='int')
dummy_2.columns = ['nota_'+ str(x) for x in list(dummy_2.columns.values)]

df = pd.concat([dummy_2,df],axis=1)

df.columns

df

df.plot(kind='scatter',x='area',y='Ef',marker='.',figsize=(10,5))

def area_bucket(x):
    if (x>10) & (x<65):
        return 1
    elif (x>65) & (x<95):
        return 2
    elif (x>95) & (x<120):
        return 3
    else:
        return 4

df['area_bucket']=df['area'].apply(area_bucket)

df

df.groupby('area_bucket')['Ef'].mean().plot(kind='bar',color='r')
plt.xlabel('Area_bucket')
plt.ylabel('Eg')

df['cluster of lattice']

plt.scatter(df['Eg'],df['Ef'],marker='.',cmap='gist_rainbow_r',c=df['cluster of lattice'])
plt.xlabel("Eg")
plt.ylabel("Ef")
plt.show()

fig, ax = plt.subplots(nrows = 2,ncols=1, sharex=True, sharey=True,)
ax[0].scatter(df['lattice_angle_alpha_degree'].values, df['Ef'].values,
              color='red', s=3, label='formation',marker='.')
ax[1].scatter(df['lattice_angle_alpha_degree'].values,df['Eg'].values,
              color='green', s=3, label='bandgap',marker='.')
fig.suptitle('Lattice angle alpha degree vsEf & Eg')
ax[0].legend(loc=0)
ax[0].set_ylabel('energy')
ax[0].set_xlabel('lattice alpha degree')
ax[1].set_ylabel('energy')
ax[1].set_xlabel('lattice alpha degree')

plt.show()

fig, ax = plt.subplots(nrows = 2,ncols=1, sharex=True, sharey=True,)
ax[0].scatter(df['lattice_angle_beta_degree'].values, df['Ef'].values,
              color='red', s=3, label='formation',marker='.')
ax[1].scatter(df['lattice_angle_beta_degree'].values,df['Eg'].values,
              color='green', s=3, label='bandgap',marker='.')
fig.suptitle('Lattice angle Beta degree vsEf & Eg')
ax[0].legend(loc=0)
ax[0].set_ylabel('energy')
ax[0].set_xlabel('lattice Beta degree')
ax[1].set_ylabel('energy')
ax[1].set_xlabel('lattice Beta degree')

plt.show()

fig, ax = plt.subplots(nrows = 2,ncols=1, sharex=True, sharey=True,)
ax[0].scatter(df['lattice_angle_gamma_degree'].values, df['Ef'].values,
              color='red', s=3, label='formation',marker='.')
ax[1].scatter(df['lattice_angle_gamma_degree'].values,df['Eg'].values,
              color='green', s=3, label='bandgap',marker='.')
fig.suptitle('Lattice angle gamma degree vsEf & Eg')
ax[0].legend(loc=0)
ax[0].set_ylabel('energy')
ax[0].set_xlabel('lattice gamma degree')
ax[1].set_ylabel('energy')
ax[1].set_xlabel('lattice gamma degree')

plt.show()

df['atomic_density'] = df['number_of_total_atoms']/(df['lattice_vector_1_ang']*df['lattice_vector_2_ang']*df['lattice_vector_3_ang'])

fig, ax = plt.subplots(nrows = 2,ncols=1, sharex=True, sharey=True,)
ax[0].scatter(df['number_of_total_atoms'].values, df['Ef'].values,
              color='red', s=3, label='formation',marker='.')
ax[1].scatter(df['number_of_total_atoms'].values,df['Eg'].values,
              color='green', s=3, label='bandgap',marker='.')
fig.suptitle('Number of atoms vsEf & Eg')
ax[0].legend(loc=0)
ax[0].set_ylabel('Ef')
ax[0].set_xlabel('Number of atoms')
ax[1].set_ylabel('Eg')
ax[1].set_xlabel('Number of atoms')

plt.show()

fig, ax = plt.subplots(nrows = 2,ncols=1, sharex=True, sharey=True,)
ax[0].scatter(df['atomic_density'].values, df['Ef'].values,
              color='red', s=3, label='formation',marker='.')
ax[1].scatter(df['atomic_density'].values,df['Eg'].values,
              color='green', s=3, label='bandgap',marker='.')
fig.suptitle('atomic_density vsEf & Eg')
ax[0].legend(loc=0)
ax[0].set_ylabel('Ef')
ax[0].set_xlabel('atomic_density')
ax[1].set_ylabel('Eg')
ax[1].set_xlabel('atomic_density')

plt.show()

fig, axes = plt.subplots(nrows=6, ncols=1, figsize=(12, 24))
plt.subplots_adjust(hspace=0.4)

for j, spacegroup in enumerate(df['spacegroup'].unique()):
    subset = df[df['spacegroup'] == spacegroup]
    axes[j].scatter(subset['Eg'], subset['Ef'], marker='.', alpha=0.7)
    axes[j].set_xlabel('Eg (eV)', fontsize=12)
    axes[j].set_title(f'Spacegroup: {spacegroup}', fontsize=14)
    axes[j].tick_params(labelsize=10)

df

del df['spacegroup'],df['number_of_total_atoms']

y_Eg=df['Eg']
y_Ef=df['Ef']

del df['Eg'],df['Ef']

df.info()



"""## **PREDICTION MODEL FOR Ef (Formation Energy (eV))**

SVR(Support Vector Regression) Model with 10-fold Cross Validation , on test data -10% of original Dataset
"""

X=df

y=y_Ef

def rmsle(y_true, y_pred):
    return np.sqrt(np.mean(np.power(np.log1p(y_pred)-np.log1p(y_true), 2)))

import numpy as np
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.preprocessing import StandardScaler
from sklearn.svm import SVR
from sklearn.metrics import make_scorer
from sklearn.pipeline import Pipeline

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1, random_state=42)

# Define the RMSLE function

# Create a scorer using the RMSLE function
rmsle_scorer = make_scorer(rmsle, greater_is_better=False)

# Create a pipeline with StandardScaler and SVR
svr_pipeline = Pipeline([
    ('scaler', StandardScaler()),
    ('svr', SVR())
])

param_grid = {
    'svr__C': [0.1, 1, 10, 100],
    'svr__epsilon': [0.01, 0.1, 0.5, 1],
    'svr__gamma': ['scale', 'auto', 0.1, 1]
}
grid_search = GridSearchCV(svr_pipeline, param_grid, cv=10, scoring=rmsle_scorer, n_jobs=-1)

grid_search.fit(X_train, y_train)

print("Best parameters:", grid_search.best_params_)
print("Best cross-validation RMSLE:", -grid_search.best_score_)

y_pred = grid_search.best_estimator_.predict(X_test)

# Calculate RMSLE on the test set
test_rmsle = rmsle(y_test, y_pred)

import joblib

test_rmsle

model =grid_search.best_estimator_
joblib.dump(model, 'model_Ef_TCO.pkl')

"""## **PREDICTION MODEL FOR Eg (Band Gap Energy (eV))**

SVR(Support Vector Regression) Model with 10-fold Cross Validation , on test data -10% of original Dataset
"""

y=y_Eg

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1, random_state=42)

# Define the RMSLE function

# Create a scorer using the RMSLE function
rmsle_scorer = make_scorer(rmsle, greater_is_better=False)

svr_pipeline = Pipeline([
    ('scaler', StandardScaler()),
    ('svr', SVR())
])

param_grid = {
    'svr__C': [0.1, 1, 10, 100],
    'svr__epsilon': [0.01, 0.1, 0.5, 1],
    'svr__gamma': ['scale', 'auto', 0.1, 1]
}
grid_search = GridSearchCV(svr_pipeline, param_grid, cv=10, scoring=rmsle_scorer, n_jobs=-1)

grid_search.fit(X_train, y_train)

print("Best parameters:", grid_search.best_params_)
print("Best cross-validation RMSLE:", -grid_search.best_score_)

y_pred = grid_search.best_estimator_.predict(X_test)

# Calculate RMSLE on the test set
test_rmsle = rmsle(y_test, y_pred)

test_rmsle

model =grid_search.best_estimator_
joblib.dump(model, 'model_Eg_TCO.pkl')

